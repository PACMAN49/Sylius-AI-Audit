{% set form = hookable_metadata.context.form ?? null %}
{% set product = hookable_metadata.context.resource ?? (form is not null ? form.vars.data : null) %}

{% set locales = [] %}
{% if product is not null %}
    {% for translation in product.translations %}
        {% if translation.locale not in locales %}
            {% set locales = locales|merge([translation.locale]) %}
        {% endif %}
    {% endfor %}
{% endif %}

{% set current_locale = app.request.locale ?? locales|first %}

{% set audit_url = product is not null and product.id is not null ? path('planetride_sylius_ai_audit_admin_ai_audit', {'id': product.id}) : null %}
{% set audit_view_url = product is not null and product.id is not null ? path('planetride_sylius_ai_audit_admin_ai_audit_view', {'id': product.id}) : null %}

<div class="tab-pane {% if hookable_metadata.configuration.active|default(false) %}show active{% endif %}" id="product-ai-audit" role="tabpanel" tabindex="0">
    <div class="card mb-3">
        <div class="card-header">
            <h2 id="product-ai-audit" class="card-title">
                Ai Audit
            </h2>
        </div>
        <div class="card-body">
            <style>
                #ai-audit-loader {
                    border-radius: 12px;
                    padding: 10px 12px;
                    margin-bottom: 10px;
                    background: linear-gradient(120deg, #f5f8ff, #eef9f6);
                    box-shadow: 0 4px 14px rgba(0, 0, 0, 0.05);
                }

                #ai-audit-loader .ai-audit-loader-icon {
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    width: 40px;
                    height: 40px;
                    border-radius: 50%;
                    font-size: 22px;
                    background: radial-gradient(circle at 30% 30%, #ffd07f, #ffb347 60%, #f9844a 100%);
                    color: #1b2a4a;
                    box-shadow: 0 0 0 4px #fff, 0 10px 25px rgba(0, 0, 0, 0.12);
                    animation: aiAuditSpin 1.4s linear infinite, aiAuditBounce 0.9s ease-in-out infinite alternate;
                }

                #ai-audit-loader .ai-audit-loader-text {
                    line-height: 1.2;
                }

                @keyframes aiAuditSpin {
                    from {
                        transform: rotate(0deg);
                    }
                    to {
                        transform: rotate(360deg);
                    }
                }

                @keyframes aiAuditBounce {
                    from {
                        transform: translateY(-3px);
                    }
                    to {
                        transform: translateY(3px);
                    }
                }

                .ai-audit-inline {
                    margin-top: 6px;
                    padding: 6px 8px;
                    border-left: 3px solid #f0ad4e;
                    background: #fff8e1;
                    color: #6c4b00;
                    font-size: 0.85rem;
                    line-height: 1.3;
                }
            </style>
            <div class="mb-3">
                <label class="form-label d-flex align-items-center gap-2 mb-2">
                    Scores d√©j√† audit√©s
                </label>
                <div class="table-responsive">
                    <table class="table table-sm align-middle mb-2">
                        <thead>
                            <tr>
                                <th class="text-nowrap">Locale</th>
                                <th class="text-nowrap">Score</th>
                                <th class="text-nowrap">Dernier audit</th>
                            </tr>
                        </thead>
                        <tbody id="ai-audit-table-body">
                            <tr>
                                <td colspan="3" class="text-muted small">Chargement des audits...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            {% if locales is not empty %}
                <div class="mb-3">
                    <label class="form-label" for="ai-audit-locale">Locale de l'audit</label>
                    <select class="form-select" id="ai-audit-locale" name="ai-audit-locale">
                        {% for locale in locales %}
                            <option value="{{ locale }}" {% if locale == current_locale %}selected{% endif %}>{{ locale }}</option>
                        {% endfor %}
                    </select>
                </div>
            {% else %}
                <p class="text-warning small">Aucune traduction trouv√©e pour ce produit. Ajoutez au moins une traduction pour lancer un audit.</p>
            {% endif %}
            <div class="mb-3">
                <label class="form-label d-flex align-items-center gap-2" for="ai-audit-score">
                    Score
                    <span id="ai-audit-score-label" class="badge bg-secondary">-</span>
                </label>
                <div class="progress" style="height: 20px;">
                    <div class="progress-bar" id="ai-audit-score-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                </div>
            </div>
            <div class="mb-3">
                <label class="form-label" for="ai-audit-retour">Retour</label>
                <textarea class="form-control" id="ai-audit-retour" name="ai-audit-retour" rows="15" readonly placeholder="Score et audit apparaitront ici"></textarea>
                <p class="text-muted small mb-0 mt-1 d-none" id="ai-audit-updated-wrapper">Dernier audit : <span id="ai-audit-updated-at"></span></p>
            </div>
            <div class="mb-3 d-grid">
                <button type="button" class="btn btn-primary" id="ai-audit-run" {% if audit_url is null %}disabled{% endif %} data-base-audit-url="{{ audit_url }}">
                    Lancer l'audit
                </button>
            </div>
            <div id="ai-audit-loader" class="d-none" aria-live="polite">
                <div class="d-flex align-items-center gap-3">
                    <div class="ai-audit-loader-icon" aria-hidden="true">ü§ñ</div>
                    <div class="ai-audit-loader-text">
                        <div class="fw-semibold text-primary">ChatGPT r√©fl√©chit...</div>
                        <div class="text-muted small">Le petit robot danse pendant l'analyse.</div>
                    </div>
                </div>
            </div>
            <p class="text-muted small mt-2 mb-0" id="ai-audit-status"></p>
        </div>
    </div>
</div>

<script>
    (function () {
        const runButton = document.getElementById('ai-audit-run');
        const retourInput = document.getElementById('ai-audit-retour');
        const statusMessage = document.getElementById('ai-audit-status');
        const scoreBar = document.getElementById('ai-audit-score-bar');
        const scoreLabel = document.getElementById('ai-audit-score-label');
        const localeSelect = document.getElementById('ai-audit-locale');
        const baseViewUrl = "{{ audit_view_url }}";
        const navBadge = document.getElementById('ai-audit-nav-score');
        const auditTableBody = document.getElementById('ai-audit-table-body');
        const locales = {{ locales|json_encode|raw }};
        const loader = document.getElementById('ai-audit-loader');
        const auditRowsByLocale = new Map();
        const inlineAuditBlockRegex = /AI_AUDIT_FIELDS:\s*([\s\S]*?)\s*END_AI_AUDIT_FIELDS/;
        let lastFieldAudits = null;

        const localeDisplay = typeof Intl !== 'undefined' && typeof Intl.DisplayNames !== 'undefined'
            ? new Intl.DisplayNames([navigator.language || 'fr'], { type: 'language' })
            : null;

        const formatLocale = (locale) => {
            if (!locale) {
                return '';
            }

            const normalized = locale.replace('_', '-');
            if (localeDisplay) {
                const name = localeDisplay.of(normalized.toLowerCase());
                if (name) {
                    return `${name} (${locale})`;
                }
            }

            return locale;
        };

        if (!runButton || !retourInput || !scoreBar || !scoreLabel) {
            return;
        }

        const setStatus = (message, variant) => {
            statusMessage.textContent = message;
            statusMessage.classList.remove('text-danger', 'text-success');

            if (variant) {
                statusMessage.classList.add(variant);
            }
        };

        const setScore = (score) => {
            const safeScore = Math.max(0, Math.min(100, Number.isFinite(score) ? score : 0));
            const red = Math.round(255 - (safeScore * 2.55));
            const green = Math.round(safeScore * 2.55);
            const color = `rgb(${red}, ${green}, 80)`;

            scoreBar.style.width = `${safeScore}%`;
            scoreBar.style.backgroundColor = color;
            scoreBar.setAttribute('aria-valuenow', String(safeScore));
            scoreLabel.textContent = `${safeScore}/100`;
            scoreLabel.classList.remove('bg-secondary');
            scoreLabel.style.backgroundColor = color;

            if (navBadge) {
                navBadge.textContent = `${safeScore}`;
                navBadge.style.backgroundColor = color;
                navBadge.style.color = '#fff';
                navBadge.classList.remove('bg-secondary');
                navBadge.classList.remove('d-none');
            }
        };

        const extractScore = (text) => {
            if (!text) {
                return null;
            }

            const match = text.match(/Score:\s*(\d{1,3})/i);
            if (!match) {
                return null;
            }

            const parsed = parseInt(match[1], 10);
            if (Number.isNaN(parsed)) {
                return null;
            }

            return Math.max(0, Math.min(100, parsed));
        };

        const parseAuditText = (text) => {
            const result = {
                cleanedText: text || '',
                fields: null,
            };

            if (!text) {
                return result;
            }

            const match = text.match(inlineAuditBlockRegex);
            if (!match) {
                return result;
            }

            const jsonText = (match[1] || '').trim();
            if (!jsonText) {
                result.cleanedText = text.replace(match[0], '').trim();
                return result;
            }

            try {
                const payload = JSON.parse(jsonText);
                if (payload && typeof payload === 'object' && payload.fields && typeof payload.fields === 'object') {
                    result.fields = payload.fields;
                }
            } catch (e) {
                // ignore invalid JSON blocks
            }

            result.cleanedText = text.replace(match[0], '').trim();
            return result;
        };

        const normalizeText = (value) => {
            return String(value || '')
                .toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .replace(/["'`]/g, '')
                .replace(/[^a-z0-9]+/g, ' ')
                .trim();
        };

        const tokenize = (value) => {
            const normalized = normalizeText(value);
            if (!normalized) {
                return [];
            }

            return normalized
                .split(' ')
                .map((token) => token.replace(/s$/i, ''))
                .filter((token) => token.length > 1);
        };

        const hasEnoughTokenOverlap = (sourceTokens, targetTokens) => {
            if (!sourceTokens.length || !targetTokens.length) {
                return false;
            }

            const targetSet = new Set(targetTokens);
            const matchCount = sourceTokens.filter((token) => targetSet.has(token)).length;
            return matchCount / sourceTokens.length >= 0.6;
        };

        const extractInlineIssues = (text) => {
            const issues = [];
            if (!text) {
                return issues;
            }

            const pattern = /\[([^\]]+)\]\s*(?:‚Üí|->|=>)\s*\[([^\]]+)\]/g;
            let match = null;
            while ((match = pattern.exec(text)) !== null) {
                const title = String(match[1] || '').trim();
                const detail = String(match[2] || '').trim();
                const combined = `${title} ${detail}`.trim();
                if (title || detail) {
                    issues.push({
                        title,
                        detail,
                        normalizedTitle: normalizeText(title),
                        normalizedText: normalizeText(combined),
                        tokens: tokenize(combined),
                    });
                }
            }

            return issues;
        };

        const resolveInlineContainer = (target) => {
            if (!target) {
                return null;
            }

            return target.closest('.flex-grow-1')
                || target.closest('.mb-3')
                || target.closest('.form-group')
                || target.closest('.field')
                || target.parentElement;
        };

        const upsertInlineAudit = (target, message, fieldKey) => {
            const trimmed = String(message || '').trim();
            if (!trimmed) {
                return;
            }

            const container = resolveInlineContainer(target);
            if (!container) {
                return;
            }

            const selector = fieldKey ? `.ai-audit-inline[data-ai-audit-field="${fieldKey}"]` : '.ai-audit-inline';
            let node = container.querySelector(selector);
            if (!node) {
                node = document.createElement('div');
                node.classList.add('ai-audit-inline');
                if (fieldKey) {
                    node.dataset.aiAuditField = fieldKey;
                }
                container.appendChild(node);
            }
            node.textContent = trimmed;
        };

        const clearInlineAudits = () => {
            document.querySelectorAll('.ai-audit-inline').forEach((node) => node.remove());
        };

        const applyInlineAuditsFromText = (text, locale) => {
            const issues = extractInlineIssues(text);
            if (!issues.length) {
                return;
            }

            const normalizedIssues = issues.filter((issue) => issue.normalizedText || issue.normalizedTitle);
            if (!normalizedIssues.length) {
                return;
            }

            const attributeFields = Array.from(document.querySelectorAll('#product-attributes input[type="hidden"][name$="[attribute]"]'))
                .map((hiddenInput) => {
                    const field = hiddenInput.closest('.field');
                    if (!field) {
                        return null;
                    }

                    const localeInput = field.querySelector('input[type="hidden"][name$="[localeCode]"]');
                    const inputLocale = localeInput ? localeInput.value : null;
                    const labelNode = field.querySelector('label');
                    const label = labelNode ? labelNode.textContent.trim() : '';
                    const attributeName = field.querySelector('[data-test-attribute-name]')?.getAttribute('data-test-attribute-name') || '';
                    const attributeCode = hiddenInput.value || '';
                    const input = field.querySelector('[data-test-attribute-name], input:not([type="hidden"]), textarea, select');

                    return {
                        field,
                        input,
                        inputLocale,
                        label: label || attributeName,
                        attributeCode,
                    };
                })
                .filter((item) => item);

            attributeFields.forEach((entry) => {
                if (!entry) {
                    return;
                }

                const inputLocale = entry.inputLocale;
                if (locale && inputLocale && inputLocale !== locale) {
                    return;
                }

                const label = entry.label || '';
                const code = entry.attributeCode || '';
                const labelTokens = tokenize(label);
                const codeTokens = tokenize(code.replace(/_/g, ' '));
                const labelNormalized = normalizeText(label);
                const codeNormalized = normalizeText(code.replace(/_/g, ' '));

                if (!labelTokens.length && !codeTokens.length) {
                    return;
                }

                const match = normalizedIssues.find((issue) => {
                    if (labelNormalized && issue.normalizedText.includes(labelNormalized)) {
                        return true;
                    }
                    if (codeNormalized && issue.normalizedText.includes(codeNormalized)) {
                        return true;
                    }
                    if (hasEnoughTokenOverlap(labelTokens, issue.tokens || tokenize(issue.title))) {
                        return true;
                    }
                    if (hasEnoughTokenOverlap(codeTokens, issue.tokens || tokenize(issue.title))) {
                        return true;
                    }
                    return false;
                });
                if (!match) {
                    return;
                }

                const message = match.detail || match.title;
                const key = labelNormalized || codeNormalized || normalizeText(label);
                const target = entry.input || entry.field;
                if (target) {
                    upsertInlineAudit(target, message, `attribute_${key}`);
                }
            });
        };

        const applyInlineAudits = (fields) => {
            clearInlineAudits();
            if (!fields || typeof fields !== 'object') {
                return;
            }

            const locale = localeSelect ? localeSelect.value : null;
            const translationRoot = locale ? document.getElementById(`translation-product-translations-${locale}`) : null;

            const translationFieldSelectors = {
                name: ['input[name$="[name]"]'],
                description: ['textarea[name$="[description]"]'],
                shortDescription: ['textarea[name$="[shortDescription]"]'],
                metaDescription: ['textarea[name$="[metaDescription]"]', 'input[name$="[metaDescription]"]'],
                metaKeywords: ['textarea[name$="[metaKeywords]"]', 'input[name$="[metaKeywords]"]'],
                metadataTitle: ['input[name$="[metadataTitle]"]', 'textarea[name$="[metadataTitle]"]'],
                metadataDescription: ['textarea[name$="[metadataDescription]"]', 'input[name$="[metadataDescription]"]'],
            };

            if (translationRoot) {
                Object.entries(translationFieldSelectors).forEach(([key, selectors]) => {
                    const message = fields[key];
                    if (!message) {
                        return;
                    }
                    for (const selector of selectors) {
                        const target = translationRoot.querySelector(selector);
                        if (target) {
                            upsertInlineAudit(target, message, key);
                            break;
                        }
                    }
                });
            }

            const generalFieldSelectors = {
                brand: ['input[name$="[brand]"]'],
                sku: ['input[name$="[sku]"]', 'input[name$="[seoSku]"]'],
                gtin8: ['input[name$="[gtin8]"]', 'input[name$="[seoGtin8]"]'],
                gtin13: ['input[name$="[gtin13]"]', 'input[name$="[seoGtin13]"]'],
                gtin14: ['input[name$="[gtin14]"]', 'input[name$="[seoGtin14]"]'],
                mpn: ['input[name$="[mpn]"]', 'input[name$="[seoMpn]"]'],
                isbn: ['input[name$="[isbn]"]', 'input[name$="[seoIsbn]"]'],
                code: ['input[name$="[code]"]'],
            };

            Object.entries(generalFieldSelectors).forEach(([key, selectors]) => {
                const message = fields[key];
                if (!message) {
                    return;
                }
                for (const selector of selectors) {
                    const target = document.querySelector(selector);
                    if (target) {
                        upsertInlineAudit(target, message, key);
                        break;
                    }
                }
            });

            if (locale) {
                Object.keys(fields)
                    .filter((key) => key.startsWith('attribute_'))
                    .forEach((key) => {
                        const message = fields[key];
                        if (!message) {
                            return;
                        }

                        const attributeCode = key.replace('attribute_', '');
                        const attributeTab = document.getElementById(attributeCode);
                        if (!attributeTab) {
                            return;
                        }

                        const fieldsInTab = Array.from(attributeTab.querySelectorAll('.field'));
                        let matchingField = null;
                        if (locale) {
                            matchingField = fieldsInTab.find((field) => {
                                const localeInput = field.querySelector('input[type="hidden"][name$="[localeCode]"]');
                                return localeInput && localeInput.value === locale;
                            }) || null;
                        }
                        if (!matchingField) {
                            matchingField = fieldsInTab[0] || null;
                        }

                        if (!matchingField) {
                            return;
                        }

                        const inputTarget = matchingField.querySelector('input:not([type="hidden"]), textarea, select');
                        if (inputTarget) {
                            upsertInlineAudit(inputTarget, message, key);
                        }
                    });
            }
        };

        const buildUrl = (baseUrl) => {
            if (!baseUrl) {
                return null;
            }

            const locale = localeSelect ? localeSelect.value : null;

            try {
                const url = new URL(baseUrl, window.location.origin);
                if (locale) {
                    url.searchParams.set('auditLocale', locale);
                }
                return url.toString();
            } catch (e) {
                return baseUrl;
            }
        };

        const buildUrlWithLocale = (baseUrl, locale) => {
            if (!baseUrl) {
                return null;
            }

            try {
                const url = new URL(baseUrl, window.location.origin);
                if (locale) {
                    url.searchParams.set('auditLocale', locale);
                }
                return url.toString();
            } catch (e) {
                return baseUrl;
            }
        };

        const renderAuditTable = (rows) => {
            if (!auditTableBody) {
                return;
            }

            auditTableBody.innerHTML = '';

            if (!rows.length) {
                auditTableBody.innerHTML = '<tr><td colspan="3" class="text-muted small">Aucun audit enregistr√© pour le moment.</td></tr>';
                return;
            }

            rows.forEach(({ locale, score, updatedAt }) => {
                const tr = document.createElement('tr');

                const tdLocale = document.createElement('td');
                tdLocale.classList.add('text-nowrap', 'fw-semibold');
                tdLocale.textContent = formatLocale(locale);

                const tdScore = document.createElement('td');
                if (score !== null && score !== undefined) {
                    const badge = document.createElement('span');
                    badge.classList.add('badge');
                    // couleur simple selon score
                    const red = Math.round(255 - (score * 2.55));
                    const green = Math.round(score * 2.55);
                    badge.style.backgroundColor = `rgb(${red}, ${green}, 80)`;
                    badge.textContent = `${score}/100`;
                    tdScore.appendChild(badge);
                } else {
                    tdScore.classList.add('text-muted');
                    tdScore.textContent = '-';
                }

                const tdDate = document.createElement('td');
                tdDate.classList.add('text-muted');
                if (updatedAt) {
                    const date = new Date(updatedAt);
                    tdDate.textContent = isNaN(date.getTime()) ? '-' : date.toLocaleString();
                } else {
                    tdDate.textContent = '-';
                }

                tr.appendChild(tdLocale);
                tr.appendChild(tdScore);
                tr.appendChild(tdDate);

                auditTableBody.appendChild(tr);
            });
        };

        const bootstrapExisting = async () => {
            const viewUrl = buildUrl(baseViewUrl);

            if (!viewUrl) {
                return;
            }

            try {
                const response = await fetch(viewUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
                if (!response.ok) {
                    return;
                }

                const payload = await response.json();
                const parsed = parseAuditText(payload.retour || '');
                retourInput.value = parsed.cleanedText || '';
                lastFieldAudits = parsed.fields;

                if (payload.score !== null && payload.score !== undefined) {
                    setScore(payload.score);
                } else if (parsed.cleanedText) {
                    const extracted = extractScore(parsed.cleanedText);
                    if (extracted !== null) {
                        setScore(extracted);
                    }
                }

                if (payload.updatedAt) {
                    const wrapper = document.getElementById('ai-audit-updated-wrapper');
                    const dateNode = document.getElementById('ai-audit-updated-at');
                    if (wrapper && dateNode) {
                        const date = new Date(payload.updatedAt);
                        if (!isNaN(date.getTime())) {
                            dateNode.textContent = date.toLocaleString();
                            wrapper.classList.remove('d-none');
                        }
                    }
                }

                if (parsed.fields && Object.values(parsed.fields).some((value) => String(value || '').trim() !== '')) {
                    applyInlineAudits(parsed.fields);
                } else {
                    clearInlineAudits();
                    applyInlineAuditsFromText(parsed.cleanedText, localeSelect ? localeSelect.value : null);
                }
            } catch (e) {
                // ignore initial load errors
            }
        };

        const fetchAllAudits = async () => {
            if (!Array.isArray(locales) || !locales.length || !baseViewUrl) {
                renderAuditTable([]);
                return;
            }

            auditRowsByLocale.clear();

            for (const locale of locales) {
                const url = buildUrlWithLocale(baseViewUrl, locale);
                if (!url) {
                    continue;
                }

                try {
                    const response = await fetch(url, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
                    if (!response.ok) {
                        continue;
                    }

                    const payload = await response.json();
                    const parsed = parseAuditText(payload.retour || '');
                    const text = parsed.cleanedText || '';
                    const scoreFromPayload = payload.score ?? null;
                    const score = scoreFromPayload !== null && scoreFromPayload !== undefined
                        ? scoreFromPayload
                        : extractScore(text);

                    auditRowsByLocale.set(locale, {
                        locale,
                        score: score !== null && score !== undefined ? Math.max(0, Math.min(100, score)) : null,
                        updatedAt: payload.updatedAt || null,
                    });
                } catch (e) {
                    // ignore per-locale errors
                }
            }

            const orderedRows = locales
                .map((item) => auditRowsByLocale.get(item))
                .filter((row) => Boolean(row));
            renderAuditTable(orderedRows);
        };

        bootstrapExisting();
        fetchAllAudits();

        if (localeSelect) {
            localeSelect.addEventListener('change', () => {
                bootstrapExisting();
                applyInlineAudits(lastFieldAudits);
            });
        }

        runButton.addEventListener('click', async () => {
            const baseAuditUrl = runButton.getAttribute('data-base-audit-url');
            const url = buildUrl(baseAuditUrl);

            if (!url) {
                setStatus('Aucun produit selectionne pour lancer l audit.', 'text-danger');
                return;
            }

            setStatus('Audit en cours...');
            runButton.setAttribute('disabled', 'disabled');
            if (loader) {
                loader.classList.remove('d-none');
            }

            try {
                const response = await fetch(url, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });

                if (!response.ok) {
                    throw new Error('Reponse inattendue du serveur.');
                }

                const payload = await response.json();

                if (!Object.prototype.hasOwnProperty.call(payload, 'retour')) {
                    throw new Error('Reponse JSON invalide.');
                }

                const parsed = parseAuditText(payload.retour || '');
                const text = parsed.cleanedText || '';
                lastFieldAudits = parsed.fields;
                retourInput.value = text;

                const score = extractScore(text);
                if (score !== null) {
                    setScore(score);
                } else {
                    setScore(0);
                }

                // rafra√Æchir le tableau des audits pour afficher imm√©diatement le nouveau score
                if (localeSelect) {
                    const locale = localeSelect.value;
                    const safeScore = payload.score ?? score;
                    auditRowsByLocale.set(locale, {
                        locale,
                        score: safeScore !== null && safeScore !== undefined ? Math.max(0, Math.min(100, safeScore)) : null,
                        updatedAt: new Date().toISOString(),
                    });
                    const orderedRows = locales
                        .map((item) => auditRowsByLocale.get(item))
                        .filter((row) => Boolean(row));
                    renderAuditTable(orderedRows);
                }

                if (parsed.fields && Object.values(parsed.fields).some((value) => String(value || '').trim() !== '')) {
                    applyInlineAudits(parsed.fields);
                } else {
                    clearInlineAudits();
                    applyInlineAuditsFromText(parsed.cleanedText, localeSelect ? localeSelect.value : null);
                }
                setStatus('Audit termine.', 'text-success');
            } catch (error) {
                setStatus(error.message || 'Impossible de lancer l audit.', 'text-danger');
            } finally {
                runButton.removeAttribute('disabled');
                if (loader) {
                    loader.classList.add('d-none');
                }
            }
        });
    })();
</script>
